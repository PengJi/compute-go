`pub fd_table: Vec<Option<Arc<dyn File + Send + Sync>>>,`
我们从外到里分别说明：
* `Vec` 的动态长度特性使得我们无需设置一个固定的文件描述符数量上限；
* `Option` 使得我们可以区分一个文件描述符当前是否空闲，当它是 `None` 的时候是空闲的，而 `Some` 则代表它已被占用；
* `Arc` 首先提供了共享引用能力。后面我们会提到，可能会有多个进程共享同一个文件对它进行读写。此外被它包裹的内容会被放到内核堆而不是栈上，于是它便不需要在编译期有着确定的大小；
* `dyn` 关键字表明 `Arc` 里面的类型实现了 `File/Send/Sync` 三个 Trait ，但是编译期无法知道它具体是哪个类型（可能是任何实现了 `File` Trait 的类型如 `Stdin/Stdout`，故而它所占的空间大小自然也无法确定），需要等到运行时才能知道它的具体类型。

Rust 中的多态
多态（Polymorphism）指的是在同一段代码中可以隐含地处理多种类型的能力。在 C++ 中，多态可以通过虚函数（Virtual Function）来实现。在 Rust 中，多态可以通过泛型和 Trait 来实现。
泛型是一种 `编译期多态 (Static Polymorphism)`，在编译一个泛型函数的时候，编译器会对于所有可能用到的类型进行实例化并对应生成一个版本的汇编代码，在编译期就能知道选取哪个版本并确定函数地址，这可能会导致生成的二进制文件体积较大。
Trait 对象（也即上面提到的 `dyn` 语法）是一种 运行时多态 (Dynamic Polymorphism)，需要在运行时查一种类似于 C++ 中的 虚表 (Virtual Table) 才能找到实际类型对于抽象接口实现的函数地址并进行调用，这样会带来一定的运行时开销，但是更为灵活。
